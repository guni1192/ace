use clap::ArgMatches;
use dirs::home_dir;

use super::container;
use super::image::Image;
use super::process::Process;
use super::vec_cstr;

pub fn run(sub_m: &ArgMatches) {
    let command = match sub_m.value_of("exec_command") {
        Some(c) => c,
        None => "/bin/sh",
    };

    let image_name = sub_m.value_of("container_name");
    let image = match image_name {
        Some(name) => Some(Image::new(name)),
        None => None,
    };

    let container_path = sub_m.value_of("container_path");

    let become_daemon = sub_m.is_present("daemonize_flag");

    let mut container = container::Container::new(image, container_path);

    let home = home_dir().expect("Could not get your home_dir");
    let home = home.to_str().expect("Could not PathBuf to str");
    // TODO: parse config.json, get spec.Process.Cwd
    let container_dir = format!("{}/.cromwell/containers", home);

    // TODO: load config.json generated by `runc spec`
    // TODO: followr runtime-spec in spec-go.Process
    let process = Process::new(
        vec_cstr![command],
        format!("{}/{}/rootfs", container_dir, container.id),
        become_daemon,
        // Example environment
        vec_cstr![
            "PATH=/bin/:/usr/bin/:/usr/local/bin:/sbin:/usr/sbin",
            "TERM=xterm-256color",
            "LC_ALL=C"
        ],
    );

    if sub_m.is_present("del") {
        container
            .delete(&process)
            .expect("Failed to remove container: ");
    }

    container.prepare(&process);
    container.run(&process);
}

pub fn pull(sub_m: &ArgMatches) {
    let image_name = sub_m
        .value_of("image_name")
        .expect("invalied arguments about image name");

    let mut image = Image::new(image_name);

    image.pull().expect("Failed to image pull");
}
